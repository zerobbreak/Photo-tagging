#!/usr/bin/env node
/**
 * @react-router/dev v7.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// invariant.ts
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    console.error(
      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
    );
    throw new Error(message);
  }
}
var init_invariant = __esm({
  "invariant.ts"() {
    "use strict";
  }
});

// config/is-react-router-repo.ts
function isReactRouterRepo() {
  let serverRuntimePath = import_pathe.default.dirname(
    require.resolve("@react-router/node/package.json")
  );
  let serverRuntimeParentDir = import_pathe.default.basename(
    import_pathe.default.resolve(serverRuntimePath, "..")
  );
  return serverRuntimeParentDir === "packages";
}
var import_pathe;
var init_is_react_router_repo = __esm({
  "config/is-react-router-repo.ts"() {
    "use strict";
    import_pathe = __toESM(require("pathe"));
  }
});

// vite/vite.ts
async function preloadVite() {
  vite = await import(viteImportSpecifier);
}
function getVite() {
  invariant(vite, "getVite() called before preloadVite()");
  return vite;
}
var import_pathe2, vite, viteImportSpecifier;
var init_vite = __esm({
  "vite/vite.ts"() {
    "use strict";
    import_pathe2 = __toESM(require("pathe"));
    init_invariant();
    init_is_react_router_repo();
    viteImportSpecifier = isReactRouterRepo() ? (
      // Support testing against different versions of Vite by ensuring that Vite
      // is resolved from the current working directory when running within this
      // repo. If we don't do this, Vite will always be imported relative to this
      // file, which means that it will always resolve to Vite 6.
      `file:///${import_pathe2.default.normalize(
        require.resolve("vite/package.json", { paths: [process.cwd()] })
      ).replace("package.json", "dist/node/index.js")}`
    ) : "vite";
  }
});

// vite/ssr-externals.ts
var ssrExternals;
var init_ssr_externals = __esm({
  "vite/ssr-externals.ts"() {
    "use strict";
    init_is_react_router_repo();
    ssrExternals = isReactRouterRepo() ? [
      // This is only needed within this repo because these packages
      // are linked to a directory outside of node_modules so Vite
      // treats them as internal code by default.
      "react-router",
      "react-router-dom",
      "@react-router/architect",
      "@react-router/cloudflare",
      "@react-router/dev",
      "@react-router/express",
      "@react-router/node",
      "@react-router/serve"
    ] : void 0;
  }
});

// vite/vite-node.ts
async function createContext({
  root,
  mode
}) {
  await preloadVite();
  const vite2 = getVite();
  const devServer = await vite2.createServer({
    root,
    mode,
    server: {
      preTransformRequests: false,
      hmr: false,
      watch: null
    },
    ssr: {
      external: ssrExternals
    },
    optimizeDeps: {
      noDiscovery: true
    },
    configFile: false,
    envFile: false,
    plugins: []
  });
  await devServer.pluginContainer.buildStart({});
  const server = new import_server.ViteNodeServer(devServer);
  (0, import_source_map.installSourcemapsSupport)({
    getSourceMap: (source) => server.getSourceMap(source)
  });
  const runner = new import_client.ViteNodeRunner({
    root: devServer.config.root,
    base: devServer.config.base,
    fetchModule(id) {
      return server.fetchModule(id);
    },
    resolveId(id, importer) {
      return server.resolveId(id, importer);
    }
  });
  return { devServer, server, runner };
}
var import_server, import_client, import_source_map;
var init_vite_node = __esm({
  "vite/vite-node.ts"() {
    "use strict";
    import_server = require("vite-node/server");
    import_client = require("vite-node/client");
    import_source_map = require("vite-node/source-map");
    init_vite();
    init_ssr_externals();
  }
});

// config/routes.ts
function setAppDirectory(directory) {
  globalThis.__reactRouterAppDirectory = directory;
}
function validateRouteConfig({
  routeConfigFile,
  routeConfig
}) {
  if (!routeConfig) {
    return {
      valid: false,
      message: `Route config must be the default export in "${routeConfigFile}".`
    };
  }
  if (!Array.isArray(routeConfig)) {
    return {
      valid: false,
      message: `Route config in "${routeConfigFile}" must be an array.`
    };
  }
  let { issues } = v.safeParse(resolvedRouteConfigSchema, routeConfig);
  if (issues?.length) {
    let { root, nested } = v.flatten(issues);
    return {
      valid: false,
      message: [
        `Route config in "${routeConfigFile}" is invalid.`,
        root ? `${root}` : [],
        nested ? Object.entries(nested).map(
          ([path9, message]) => `Path: routes.${path9}
${message}`
        ) : []
      ].flat().join("\n\n")
    };
  }
  return { valid: true };
}
function configRoutesToRouteManifest(appDirectory, routes2, rootId = "root") {
  let routeManifest = {};
  function walk(route, parentId) {
    let id = route.id || createRouteId(route.file);
    let manifestItem = {
      id,
      parentId,
      file: Path.isAbsolute(route.file) ? Path.relative(appDirectory, route.file) : route.file,
      path: route.path,
      index: route.index,
      caseSensitive: route.caseSensitive
    };
    if (routeManifest.hasOwnProperty(id)) {
      throw new Error(
        `Unable to define routes with duplicate route id: "${id}"`
      );
    }
    routeManifest[id] = manifestItem;
    if (route.children) {
      for (let child of route.children) {
        walk(child, id);
      }
    }
  }
  for (let route of routes2) {
    walk(route, rootId);
  }
  return routeManifest;
}
function createRouteId(file) {
  return Path.normalize(stripFileExtension(file));
}
function stripFileExtension(file) {
  return file.replace(/\.[a-z0-9]+$/i, "");
}
var Path, v, import_pick, routeConfigEntrySchema, resolvedRouteConfigSchema;
var init_routes = __esm({
  "config/routes.ts"() {
    "use strict";
    Path = __toESM(require("pathe"));
    v = __toESM(require("valibot"));
    import_pick = __toESM(require("lodash/pick"));
    init_invariant();
    routeConfigEntrySchema = v.pipe(
      v.custom((value) => {
        return !(typeof value === "object" && value !== null && "then" in value && "catch" in value);
      }, "Invalid type: Expected object but received a promise. Did you forget to await?"),
      v.object({
        id: v.optional(v.string()),
        path: v.optional(v.string()),
        index: v.optional(v.boolean()),
        caseSensitive: v.optional(v.boolean()),
        file: v.string(),
        children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema)))
      })
    );
    resolvedRouteConfigSchema = v.array(routeConfigEntrySchema);
  }
});

// cli/detectPackageManager.ts
var init_detectPackageManager = __esm({
  "cli/detectPackageManager.ts"() {
    "use strict";
  }
});

// config/config.ts
function ok(value) {
  return { ok: true, value };
}
function err(error) {
  return { ok: false, error };
}
async function resolveConfig({
  root,
  viteNodeContext,
  reactRouterConfigFile
}) {
  let reactRouterUserConfig = {};
  if (reactRouterConfigFile) {
    try {
      if (!import_node_fs.default.existsSync(reactRouterConfigFile)) {
        return err(`${reactRouterConfigFile} no longer exists`);
      }
      let configModule = await viteNodeContext.runner.executeFile(
        reactRouterConfigFile
      );
      if (configModule.default === void 0) {
        return err(`${reactRouterConfigFile} must provide a default export`);
      }
      if (typeof configModule.default !== "object") {
        return err(`${reactRouterConfigFile} must export a config`);
      }
      reactRouterUserConfig = configModule.default;
    } catch (error) {
      return err(`Error loading ${reactRouterConfigFile}: ${error}`);
    }
  }
  reactRouterUserConfig = deepFreeze((0, import_cloneDeep.default)(reactRouterUserConfig));
  let presets = (await Promise.all(
    (reactRouterUserConfig.presets ?? []).map(async (preset) => {
      if (!preset.name) {
        throw new Error(
          "React Router presets must have a `name` property defined."
        );
      }
      if (!preset.reactRouterConfig) {
        return null;
      }
      let configPreset = (0, import_omit.default)(
        await preset.reactRouterConfig({ reactRouterUserConfig }),
        excludedConfigPresetKeys
      );
      return configPreset;
    })
  )).filter(function isNotNull(value) {
    return value !== null;
  });
  let defaults = {
    basename: "/",
    buildDirectory: "build",
    serverBuildFile: "index.js",
    serverModuleFormat: "esm",
    ssr: true
  };
  let {
    appDirectory: userAppDirectory,
    basename: basename2,
    buildDirectory: userBuildDirectory,
    buildEnd,
    prerender,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr
  } = {
    ...defaults,
    // Default values should be completely overridden by user/preset config, not merged
    ...mergeReactRouterConfig(...presets, reactRouterUserConfig)
  };
  if (!ssr && serverBundles) {
    serverBundles = void 0;
  }
  let isValidPrerenderConfig = prerender == null || typeof prerender === "boolean" || Array.isArray(prerender) || typeof prerender === "function";
  if (!isValidPrerenderConfig) {
    return err(
      "The `prerender` config must be a boolean, an array of string paths, or a function returning a boolean or array of string paths"
    );
  }
  let appDirectory = import_pathe3.default.resolve(root, userAppDirectory || "app");
  let buildDirectory = import_pathe3.default.resolve(root, userBuildDirectory);
  let rootRouteFile = findEntry(appDirectory, "root");
  if (!rootRouteFile) {
    let rootRouteDisplayPath = import_pathe3.default.relative(
      root,
      import_pathe3.default.join(appDirectory, "root.tsx")
    );
    return err(
      `Could not find a root route module in the app directory as "${rootRouteDisplayPath}"`
    );
  }
  let routes2 = {
    root: { path: "", id: "root", file: rootRouteFile }
  };
  let routeConfigFile = findEntry(appDirectory, "routes");
  try {
    if (!routeConfigFile) {
      let routeConfigDisplayPath = import_pathe3.default.relative(
        root,
        import_pathe3.default.join(appDirectory, "routes.ts")
      );
      return err(`Route config file not found at "${routeConfigDisplayPath}".`);
    }
    setAppDirectory(appDirectory);
    let routeConfigExport = (await viteNodeContext.runner.executeFile(
      import_pathe3.default.join(appDirectory, routeConfigFile)
    )).default;
    let routeConfig = await routeConfigExport;
    let result = validateRouteConfig({
      routeConfigFile,
      routeConfig
    });
    if (!result.valid) {
      return err(result.message);
    }
    routes2 = {
      ...routes2,
      ...configRoutesToRouteManifest(appDirectory, routeConfig)
    };
  } catch (error) {
    return err(
      [
        import_picocolors.default.red(`Route config in "${routeConfigFile}" is invalid.`),
        "",
        error.loc?.file && error.loc?.column && error.frame ? [
          import_pathe3.default.relative(appDirectory, error.loc.file) + ":" + error.loc.line + ":" + error.loc.column,
          error.frame.trim?.()
        ] : error.stack
      ].flat().join("\n")
    );
  }
  let future = {
    unstable_middleware: reactRouterUserConfig.future?.unstable_middleware ?? false,
    unstable_optimizeDeps: reactRouterUserConfig.future?.unstable_optimizeDeps ?? false,
    unstable_splitRouteModules: reactRouterUserConfig.future?.unstable_splitRouteModules ?? false,
    unstable_subResourceIntegrity: reactRouterUserConfig.future?.unstable_subResourceIntegrity ?? false,
    unstable_viteEnvironmentApi: reactRouterUserConfig.future?.unstable_viteEnvironmentApi ?? false
  };
  let reactRouterConfig = deepFreeze({
    appDirectory,
    basename: basename2,
    buildDirectory,
    buildEnd,
    future,
    prerender,
    routes: routes2,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr
  });
  for (let preset of reactRouterUserConfig.presets ?? []) {
    await preset.reactRouterConfigResolved?.({ reactRouterConfig });
  }
  return ok(reactRouterConfig);
}
async function createConfigLoader({
  rootDirectory: root,
  watch: watch2
}) {
  root = root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd();
  let viteNodeContext = await createContext({
    root,
    mode: watch2 ? "development" : "production"
  });
  let reactRouterConfigFile = findEntry(root, "react-router.config", {
    absolute: true
  });
  let getConfig = () => resolveConfig({ root, viteNodeContext, reactRouterConfigFile });
  let appDirectory;
  let initialConfigResult = await getConfig();
  if (!initialConfigResult.ok) {
    throw new Error(initialConfigResult.error);
  }
  appDirectory = initialConfigResult.value.appDirectory;
  let lastConfig = initialConfigResult.value;
  let fsWatcher;
  let changeHandlers = [];
  return {
    getConfig,
    onChange: (handler) => {
      if (!watch2) {
        throw new Error(
          "onChange is not supported when watch mode is disabled"
        );
      }
      changeHandlers.push(handler);
      if (!fsWatcher) {
        fsWatcher = import_chokidar.default.watch(
          [
            ...reactRouterConfigFile ? [reactRouterConfigFile] : [],
            appDirectory
          ],
          { ignoreInitial: true }
        );
        fsWatcher.on("all", async (...args) => {
          let [event, rawFilepath] = args;
          let filepath = import_pathe3.default.normalize(rawFilepath);
          let appFileAddedOrRemoved = appDirectory && (event === "add" || event === "unlink") && filepath.startsWith(import_pathe3.default.normalize(appDirectory));
          let configCodeUpdated = Boolean(
            viteNodeContext.devServer?.moduleGraph.getModuleById(filepath)
          );
          if (configCodeUpdated || appFileAddedOrRemoved) {
            viteNodeContext.devServer?.moduleGraph.invalidateAll();
            viteNodeContext.runner?.moduleCache.clear();
          }
          if (appFileAddedOrRemoved || configCodeUpdated) {
            let result = await getConfig();
            let configChanged = result.ok && !(0, import_isEqual.default)(lastConfig, result.value);
            let routeConfigChanged = result.ok && !(0, import_isEqual.default)(lastConfig?.routes, result.value.routes);
            for (let handler2 of changeHandlers) {
              handler2({
                result,
                configCodeUpdated,
                configChanged,
                routeConfigChanged,
                path: filepath,
                event
              });
            }
            if (result.ok) {
              lastConfig = result.value;
            }
          }
        });
      }
      return () => {
        changeHandlers = changeHandlers.filter(
          (changeHandler) => changeHandler !== handler
        );
      };
    },
    close: async () => {
      changeHandlers = [];
      await viteNodeContext.devServer.close();
      await fsWatcher?.close();
    }
  };
}
async function loadConfig({ rootDirectory }) {
  let configLoader = await createConfigLoader({
    rootDirectory,
    watch: false
  });
  let config = await configLoader.getConfig();
  await configLoader.close();
  return config;
}
function findEntry(dir, basename2, options) {
  for (let ext of entryExts) {
    let file = import_pathe3.default.resolve(dir, basename2 + ext);
    if (import_node_fs.default.existsSync(file)) {
      return options?.absolute ?? false ? file : import_pathe3.default.relative(dir, file);
    }
  }
  return void 0;
}
var import_node_fs, import_node_child_process, import_package_json, import_pathe3, import_chokidar, import_picocolors, import_pick2, import_omit, import_cloneDeep, import_isEqual, excludedConfigPresetKeys, mergeReactRouterConfig, deepFreeze, entryExts;
var init_config = __esm({
  "config/config.ts"() {
    "use strict";
    import_node_fs = __toESM(require("fs"));
    import_node_child_process = require("child_process");
    import_package_json = __toESM(require("@npmcli/package-json"));
    init_vite_node();
    import_pathe3 = __toESM(require("pathe"));
    import_chokidar = __toESM(require("chokidar"));
    import_picocolors = __toESM(require("picocolors"));
    import_pick2 = __toESM(require("lodash/pick"));
    import_omit = __toESM(require("lodash/omit"));
    import_cloneDeep = __toESM(require("lodash/cloneDeep"));
    import_isEqual = __toESM(require("lodash/isEqual"));
    init_routes();
    init_detectPackageManager();
    excludedConfigPresetKeys = ["presets"];
    mergeReactRouterConfig = (...configs) => {
      let reducer = (configA, configB) => {
        let mergeRequired = (key) => configA[key] !== void 0 && configB[key] !== void 0;
        return {
          ...configA,
          ...configB,
          ...mergeRequired("buildEnd") ? {
            buildEnd: async (...args) => {
              await Promise.all([
                configA.buildEnd?.(...args),
                configB.buildEnd?.(...args)
              ]);
            }
          } : {},
          ...mergeRequired("future") ? {
            future: {
              ...configA.future,
              ...configB.future
            }
          } : {},
          ...mergeRequired("presets") ? {
            presets: [...configA.presets ?? [], ...configB.presets ?? []]
          } : {}
        };
      };
      return configs.reduce(reducer, {});
    };
    deepFreeze = (o) => {
      Object.freeze(o);
      let oIsFunction = typeof o === "function";
      let hasOwnProp = Object.prototype.hasOwnProperty;
      Object.getOwnPropertyNames(o).forEach(function(prop) {
        if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== "caller" && prop !== "callee" && prop !== "arguments" : true) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
          deepFreeze(o[prop]);
        }
      });
      return o;
    };
    entryExts = [".js", ".jsx", ".ts", ".tsx"];
  }
});

// vite/profiler.ts
var import_node_fs2, import_node_path, import_picocolors2, getSession, start, profileCount, stop;
var init_profiler = __esm({
  "vite/profiler.ts"() {
    "use strict";
    import_node_fs2 = __toESM(require("fs"));
    import_node_path = __toESM(require("path"));
    import_picocolors2 = __toESM(require("picocolors"));
    getSession = () => global.__reactRouter_profile_session;
    start = async (callback) => {
      let inspector = await import("inspector").then((r) => r.default);
      let session = global.__reactRouter_profile_session = new inspector.Session();
      session.connect();
      session.post("Profiler.enable", () => {
        session.post("Profiler.start", callback);
      });
    };
    profileCount = 0;
    stop = (log) => {
      let session = getSession();
      if (!session) return;
      return new Promise((res, rej) => {
        session.post("Profiler.stop", (err2, { profile }) => {
          if (err2) return rej(err2);
          let outPath = import_node_path.default.resolve(`./react-router-${profileCount++}.cpuprofile`);
          import_node_fs2.default.writeFileSync(outPath, JSON.stringify(profile));
          log(
            import_picocolors2.default.yellow(
              `CPU profile written to ${import_picocolors2.default.white(import_picocolors2.default.dim(outPath))}`
            )
          );
          global.__reactRouter_profile_session = void 0;
          res();
        });
      });
    };
  }
});

// vite/babel.ts
var babel_exports = {};
__export(babel_exports, {
  generate: () => generate,
  parse: () => import_parser.parse,
  t: () => t,
  traverse: () => traverse
});
var import_parser, t, traverse, generate;
var init_babel = __esm({
  "vite/babel.ts"() {
    "use strict";
    import_parser = require("@babel/parser");
    t = __toESM(require("@babel/types"));
    traverse = require("@babel/traverse").default;
    generate = require("@babel/generator").default;
  }
});

// typegen/paths.ts
function getTypesDir(ctx) {
  return Path2.join(ctx.rootDirectory, ".react-router/types");
}
function getTypesPath(ctx, route) {
  return Path2.join(
    getTypesDir(ctx),
    Path2.relative(ctx.rootDirectory, ctx.config.appDirectory),
    Path2.dirname(route.file),
    "+types/" + Pathe.filename(route.file) + ".ts"
  );
}
var Path2, Pathe;
var init_paths = __esm({
  "typegen/paths.ts"() {
    "use strict";
    Path2 = __toESM(require("pathe"));
    Pathe = __toESM(require("pathe/utils"));
  }
});

// typegen/params.ts
function parse2(fullpath2) {
  const result = {};
  let segments = fullpath2.split("/");
  segments.forEach((segment) => {
    const match = segment.match(/^:([\w-]+)(\?)?/);
    if (!match) return;
    const param = match[1];
    const isRequired = match[2] === void 0;
    result[param] ||= isRequired;
    return;
  });
  const hasSplat = segments.at(-1) === "*";
  if (hasSplat) result["*"] = true;
  return result;
}
var init_params = __esm({
  "typegen/params.ts"() {
    "use strict";
  }
});

// typegen/route.ts
function lineage(routes2, route) {
  const result = [];
  while (route) {
    result.push(route);
    if (!route.parentId) break;
    route = routes2[route.parentId];
  }
  result.reverse();
  return result;
}
function fullpath(lineage2) {
  if (lineage2.length === 1 && lineage2[0].id === "root") return "/";
  return "/" + lineage2.map((route) => route.path?.replace(/^\//, "")?.replace(/\/$/, "")).filter((path9) => path9 !== void 0 && path9 !== "").join("/");
}
var init_route = __esm({
  "typegen/route.ts"() {
    "use strict";
  }
});

// typegen/generate.ts
function generate2(ctx, route) {
  const lineage2 = lineage(ctx.config.routes, route);
  const fullpath2 = fullpath(lineage2);
  const typesPath = getTypesPath(ctx, route);
  const parents = lineage2.slice(0, -1);
  const parentTypeImports = parents.map((parent, i) => {
    const rel = Path3.relative(
      Path3.dirname(typesPath),
      getTypesPath(ctx, parent)
    );
    const indent = i === 0 ? "" : "  ".repeat(2);
    let source = noExtension(rel);
    if (!source.startsWith("../")) source = "./" + source;
    return `${indent}import type { Info as Parent${i} } from "${source}.js"`;
  }).join("\n");
  return import_dedent.default`
    // React Router generated types for route:
    // ${route.file}

    import type * as T from "react-router/route-module"

    ${parentTypeImports}

    type Module = typeof import("../${Pathe2.filename(route.file)}.js")

    export type Info = {
      parents: [${parents.map((_, i) => `Parent${i}`).join(", ")}],
      id: "${route.id}"
      file: "${route.file}"
      path: "${route.path}"
      params: {${formatParamProperties(
    fullpath2
  )}} & { [key: string]: string | undefined }
      module: Module
      loaderData: T.CreateLoaderData<Module>
      actionData: T.CreateActionData<Module>
    }

    export namespace Route {
      export type LinkDescriptors = T.LinkDescriptors
      export type LinksFunction = () => LinkDescriptors

      export type MetaArgs = T.CreateMetaArgs<Info>
      export type MetaDescriptors = T.MetaDescriptors
      export type MetaFunction = (args: MetaArgs) => MetaDescriptors

      export type HeadersArgs = T.HeadersArgs
      export type HeadersFunction = (args: HeadersArgs) => Headers | HeadersInit

      export type unstable_MiddlewareFunction = T.CreateServerMiddlewareFunction<Info>
      export type unstable_ClientMiddlewareFunction = T.CreateClientMiddlewareFunction<Info>
      export type LoaderArgs = T.CreateServerLoaderArgs<Info>
      export type ClientLoaderArgs = T.CreateClientLoaderArgs<Info>
      export type ActionArgs = T.CreateServerActionArgs<Info>
      export type ClientActionArgs = T.CreateClientActionArgs<Info>

      export type HydrateFallbackProps = T.CreateHydrateFallbackProps<Info>
      export type ComponentProps = T.CreateComponentProps<Info>
      export type ErrorBoundaryProps = T.CreateErrorBoundaryProps<Info>
    }
  `;
}
function formatParamProperties(fullpath2) {
  const params = parse2(fullpath2);
  const properties = Object.entries(params).map(
    ([name, isRequired]) => isRequired ? `"${name}": string` : `"${name}"?: string`
  );
  return properties.join("; ");
}
var import_dedent, Path3, Pathe2, noExtension;
var init_generate = __esm({
  "typegen/generate.ts"() {
    "use strict";
    import_dedent = __toESM(require("dedent"));
    Path3 = __toESM(require("pathe"));
    Pathe2 = __toESM(require("pathe/utils"));
    init_paths();
    init_params();
    init_route();
    noExtension = (path9) => Path3.join(Path3.dirname(path9), Pathe2.filename(path9));
  }
});

// typegen/index.ts
async function run(rootDirectory) {
  const ctx = await createContext2({ rootDirectory, watch: false });
  await writeAll(ctx);
}
async function watch(rootDirectory, { logger } = {}) {
  const ctx = await createContext2({ rootDirectory, watch: true });
  await writeAll(ctx);
  logger?.info(import_picocolors3.default.green("generated types"), { timestamp: true, clear: true });
  ctx.configLoader.onChange(async ({ result, routeConfigChanged }) => {
    if (!result.ok) {
      logger?.error(import_picocolors3.default.red(result.error), { timestamp: true, clear: true });
      return;
    }
    ctx.config = result.value;
    if (routeConfigChanged) {
      await writeAll(ctx);
      logger?.info(import_picocolors3.default.green("regenerated types"), {
        timestamp: true,
        clear: true
      });
    }
  });
  return {
    close: async () => await ctx.configLoader.close()
  };
}
async function createContext2({
  rootDirectory,
  watch: watch2
}) {
  const configLoader = await createConfigLoader({ rootDirectory, watch: watch2 });
  const configResult = await configLoader.getConfig();
  if (!configResult.ok) {
    throw new Error(configResult.error);
  }
  const config = configResult.value;
  return {
    configLoader,
    rootDirectory,
    config
  };
}
async function writeAll(ctx) {
  const typegenDir = getTypesDir(ctx);
  import_node_fs3.default.rmSync(typegenDir, { recursive: true, force: true });
  Object.values(ctx.config.routes).forEach((route) => {
    const typesPath = getTypesPath(ctx, route);
    const content = generate2(ctx, route);
    import_node_fs3.default.mkdirSync(Path4.dirname(typesPath), { recursive: true });
    import_node_fs3.default.writeFileSync(typesPath, content);
  });
  const registerPath = Path4.join(typegenDir, "+register.ts");
  import_node_fs3.default.writeFileSync(registerPath, register(ctx));
  const virtualPath = Path4.join(typegenDir, "+virtual.d.ts");
  import_node_fs3.default.writeFileSync(virtualPath, virtual);
}
function register(ctx) {
  const register2 = import_dedent2.default`
    import "react-router";

    declare module "react-router" {
      interface Register {
        params: Params;
      }
    }
  `;
  const { t: t2 } = babel_exports;
  const indexPaths = new Set(
    Object.values(ctx.config.routes).filter((route) => route.index).map((route) => route.path)
  );
  const typeParams = t2.tsTypeAliasDeclaration(
    t2.identifier("Params"),
    null,
    t2.tsTypeLiteral(
      Object.values(ctx.config.routes).map((route) => {
        if (route.id !== "root" && !route.path) return void 0;
        if (!route.index && indexPaths.has(route.path)) return void 0;
        const lineage2 = lineage(ctx.config.routes, route);
        const fullpath2 = fullpath(lineage2);
        const params = parse2(fullpath2);
        return t2.tsPropertySignature(
          t2.stringLiteral(fullpath2),
          t2.tsTypeAnnotation(
            t2.tsTypeLiteral(
              Object.entries(params).map(([param, isRequired]) => {
                const property = t2.tsPropertySignature(
                  t2.stringLiteral(param),
                  t2.tsTypeAnnotation(t2.tsStringKeyword())
                );
                property.optional = !isRequired;
                return property;
              })
            )
          )
        );
      }).filter((x) => x !== void 0)
    )
  );
  return [register2, generate(typeParams).code].join("\n\n");
}
var import_node_fs3, import_dedent2, Path4, import_picocolors3, virtual;
var init_typegen = __esm({
  "typegen/index.ts"() {
    "use strict";
    import_node_fs3 = __toESM(require("fs"));
    import_dedent2 = __toESM(require("dedent"));
    Path4 = __toESM(require("pathe"));
    import_picocolors3 = __toESM(require("picocolors"));
    init_config();
    init_babel();
    init_generate();
    init_paths();
    init_params();
    init_route();
    virtual = import_dedent2.default`
  declare module "virtual:react-router/server-build" {
    import { ServerBuild } from "react-router";
    export const assets: ServerBuild["assets"];
    export const assetsBuildDirectory: ServerBuild["assetsBuildDirectory"];
    export const basename: ServerBuild["basename"];
    export const entry: ServerBuild["entry"];
    export const future: ServerBuild["future"];
    export const isSpaMode: ServerBuild["isSpaMode"];
    export const prerender: ServerBuild["prerender"];
    export const publicPath: ServerBuild["publicPath"];
    export const routes: ServerBuild["routes"];
    export const ssr: ServerBuild["ssr"];
    export const unstable_getCriticalCss: ServerBuild["unstable_getCriticalCss"];
  }
`;
  }
});

// vite/node-adapter.ts
var import_node_events, import_node_stream, import_set_cookie_parser, import_node;
var init_node_adapter = __esm({
  "vite/node-adapter.ts"() {
    "use strict";
    import_node_events = require("events");
    import_node_stream = require("stream");
    import_set_cookie_parser = require("set-cookie-parser");
    import_node = require("@react-router/node");
    init_invariant();
  }
});

// vite/resolve-file-url.ts
var path5;
var init_resolve_file_url = __esm({
  "vite/resolve-file-url.ts"() {
    "use strict";
    path5 = __toESM(require("path"));
    init_vite();
  }
});

// vite/styles.ts
var path6, import_react_router, cssFileRegExp, cssModulesRegExp;
var init_styles = __esm({
  "vite/styles.ts"() {
    "use strict";
    path6 = __toESM(require("path"));
    import_react_router = require("react-router");
    init_resolve_file_url();
    cssFileRegExp = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
    cssModulesRegExp = new RegExp(`\\.module${cssFileRegExp.source}`);
  }
});

// vite/virtual-module.ts
function create(name) {
  let id = `virtual:react-router/${name}`;
  return {
    id,
    resolvedId: `\0${id}`,
    url: `/@id/__x00__${id}`
  };
}
var init_virtual_module = __esm({
  "vite/virtual-module.ts"() {
    "use strict";
  }
});

// vite/combine-urls.ts
var init_combine_urls = __esm({
  "vite/combine-urls.ts"() {
    "use strict";
  }
});

// vite/remove-exports.ts
var import_babel_dead_code_elimination;
var init_remove_exports = __esm({
  "vite/remove-exports.ts"() {
    "use strict";
    import_babel_dead_code_elimination = require("babel-dead-code-elimination");
    init_babel();
  }
});

// vite/cache.ts
var init_cache = __esm({
  "vite/cache.ts"() {
    "use strict";
  }
});

// vite/route-chunks.ts
function getRouteChunkModuleId(filePath, chunkName) {
  return `${filePath}${routeChunkQueryStrings[chunkName]}`;
}
function isRouteChunkModuleId(id) {
  return Object.values(routeChunkQueryStrings).some(
    (queryString) => id.endsWith(queryString)
  );
}
function isRouteChunkName(name) {
  return name === mainChunkName || routeChunkExportNames.includes(name);
}
function getRouteChunkNameFromModuleId(id) {
  if (!isRouteChunkModuleId(id)) {
    return null;
  }
  let chunkName = id.split(routeChunkQueryStringPrefix)[1].split("&")[0];
  if (!isRouteChunkName(chunkName)) {
    return null;
  }
  return chunkName;
}
var routeChunkExportNames, mainChunkName, routeChunkNames, routeChunkQueryStringPrefix, routeChunkQueryStrings;
var init_route_chunks = __esm({
  "vite/route-chunks.ts"() {
    "use strict";
    init_invariant();
    init_cache();
    init_babel();
    routeChunkExportNames = [
      "clientAction",
      "clientLoader",
      "unstable_clientMiddleware",
      "HydrateFallback"
    ];
    mainChunkName = "main";
    routeChunkNames = ["main", ...routeChunkExportNames];
    routeChunkQueryStringPrefix = "?route-chunk=";
    routeChunkQueryStrings = {
      main: `${routeChunkQueryStringPrefix}main`,
      clientAction: `${routeChunkQueryStringPrefix}clientAction`,
      clientLoader: `${routeChunkQueryStringPrefix}clientLoader`,
      unstable_clientMiddleware: `${routeChunkQueryStringPrefix}unstable_clientMiddleware`,
      HydrateFallback: `${routeChunkQueryStringPrefix}HydrateFallback`
    };
  }
});

// vite/with-props.ts
var import_dedent3, vmod;
var init_with_props = __esm({
  "vite/with-props.ts"() {
    "use strict";
    import_dedent3 = __toESM(require("dedent"));
    init_babel();
    init_virtual_module();
    vmod = create("with-props");
  }
});

// vite/plugin.ts
async function resolveViteConfig({
  configFile,
  mode,
  root,
  plugins
}) {
  let vite2 = getVite();
  let viteConfig = await vite2.resolveConfig(
    { mode, configFile, root, plugins },
    "build",
    // command
    "production",
    // default mode
    "production"
    // default NODE_ENV
  );
  if (typeof viteConfig.build.manifest === "string") {
    throw new Error("Custom Vite manifest paths are not supported");
  }
  return viteConfig;
}
function extractPluginContext(viteConfig) {
  return viteConfig["__reactRouterPluginContext"];
}
function isSsrBundleEnvironmentName(name) {
  return name.startsWith(SSR_BUNDLE_PREFIX);
}
function getServerEnvironmentEntries(ctx, record) {
  return Object.entries(record).filter(
    ([name]) => ctx.buildManifest?.serverBundles ? isSsrBundleEnvironmentName(name) : name === "ssr"
  );
}
function getServerEnvironmentKeys(ctx, record) {
  return getServerEnvironmentEntries(ctx, record).map(([key]) => key);
}
function getServerBundleIds(ctx) {
  return ctx.buildManifest?.serverBundles ? Object.keys(ctx.buildManifest.serverBundles) : void 0;
}
async function cleanBuildDirectory(viteConfig, ctx) {
  let buildDirectory = ctx.reactRouterConfig.buildDirectory;
  let isWithinRoot = () => {
    let relativePath = path7.relative(ctx.rootDirectory, buildDirectory);
    return !relativePath.startsWith("..") && !path7.isAbsolute(relativePath);
  };
  if (viteConfig.build.emptyOutDir ?? isWithinRoot()) {
    await fse.remove(buildDirectory);
  }
}
async function cleanViteManifests(environmentsOptions, ctx) {
  let viteManifestPaths = Object.entries(environmentsOptions).map(
    ([environmentName, options]) => {
      let outDir = options.build?.outDir;
      invariant(outDir, `Expected build.outDir for ${environmentName}`);
      return path7.join(outDir, ".vite/manifest.json");
    }
  );
  await Promise.all(
    viteManifestPaths.map(async (viteManifestPath) => {
      let manifestExists = await fse.pathExists(viteManifestPath);
      if (!manifestExists) return;
      if (!ctx.viteManifestEnabled) {
        await fse.remove(viteManifestPath);
      }
      let viteDir = path7.dirname(viteManifestPath);
      let viteDirFiles = await fse.readdir(viteDir);
      if (viteDirFiles.length === 0) {
        await fse.remove(viteDir);
      }
    })
  );
}
function mergeEnvironmentOptions(base, ...overrides) {
  let vite2 = getVite();
  return overrides.reduce(
    (merged, override) => vite2.mergeConfig(merged, override, false),
    base
  );
}
async function getEnvironmentOptionsResolvers(ctx, viteCommand) {
  let { serverBuildFile, serverModuleFormat } = ctx.reactRouterConfig;
  let packageRoot = path7.dirname(
    require.resolve("@react-router/dev/package.json")
  );
  let { moduleSyncEnabled } = await import(`file:///${path7.join(packageRoot, "module-sync-enabled/index.mjs")}`);
  let vite2 = getVite();
  let viteServerConditions = [
    ...vite2.defaultServerConditions ?? [],
    ...moduleSyncEnabled ? ["module-sync"] : []
  ];
  function getBaseOptions({
    viteUserConfig
  }) {
    return {
      build: {
        cssMinify: viteUserConfig.build?.cssMinify ?? true,
        manifest: true,
        // The manifest is enabled for all builds to detect SSR-only assets
        rollupOptions: {
          preserveEntrySignatures: "exports-only",
          // Silence Rollup "use client" warnings
          // Adapted from https://github.com/vitejs/vite-plugin-react/pull/144
          onwarn(warning, defaultHandler) {
            if (warning.code === "MODULE_LEVEL_DIRECTIVE" && warning.message.includes("use client")) {
              return;
            }
            let userHandler = viteUserConfig.build?.rollupOptions?.onwarn;
            if (userHandler) {
              userHandler(warning, defaultHandler);
            } else {
              defaultHandler(warning);
            }
          }
        }
      }
    };
  }
  function getBaseServerOptions({
    viteUserConfig
  }) {
    let conditions = viteCommand === "build" ? viteServerConditions : ["development", ...viteServerConditions];
    return mergeEnvironmentOptions(getBaseOptions({ viteUserConfig }), {
      resolve: {
        external: (
          // If `unstable_viteEnvironmentApi` is `true`, `resolve.external` is set in the `configEnvironment` hook
          ctx.reactRouterConfig.future.unstable_viteEnvironmentApi ? void 0 : ssrExternals
        ),
        conditions,
        externalConditions: conditions
      },
      build: {
        // We move SSR-only assets to client assets. Note that the
        // SSR build can also emit code-split JS files (e.g. by
        // dynamic import) under the same assets directory
        // regardless of "ssrEmitAssets" option, so we also need to
        // keep these JS files have to be kept as-is.
        ssrEmitAssets: true,
        copyPublicDir: false,
        // Assets in the public directory are only used by the client
        rollupOptions: {
          input: (ctx.reactRouterConfig.future.unstable_viteEnvironmentApi ? viteUserConfig.environments?.ssr?.build?.rollupOptions?.input : viteUserConfig.build?.rollupOptions?.input) ?? virtual2.serverBuild.id,
          output: {
            entryFileNames: serverBuildFile,
            format: serverModuleFormat
          }
        }
      }
    });
  }
  let environmentOptionsResolvers = {
    client: ({ viteUserConfig }) => mergeEnvironmentOptions(getBaseOptions({ viteUserConfig }), {
      build: {
        rollupOptions: {
          input: [
            ctx.entryClientFilePath,
            ...Object.values(ctx.reactRouterConfig.routes).flatMap(
              (route) => {
                let routeFilePath = path7.resolve(
                  ctx.reactRouterConfig.appDirectory,
                  route.file
                );
                let isRootRoute = route.file === ctx.reactRouterConfig.routes.root.file;
                let code = fse.readFileSync(routeFilePath, "utf-8");
                return [
                  `${routeFilePath}${BUILD_CLIENT_ROUTE_QUERY_STRING}`,
                  ...ctx.reactRouterConfig.future.unstable_splitRouteModules && !isRootRoute ? routeChunkExportNames.map(
                    (exportName) => code.includes(exportName) ? getRouteChunkModuleId(routeFilePath, exportName) : null
                  ) : []
                ].filter(isNonNullable);
              }
            )
          ],
          output: (ctx.reactRouterConfig.future.unstable_viteEnvironmentApi ? viteUserConfig?.environments?.client?.build?.rollupOptions?.output : viteUserConfig?.build?.rollupOptions?.output) ?? {
            entryFileNames: ({ moduleIds }) => {
              let routeChunkModuleId = moduleIds.find(isRouteChunkModuleId);
              let routeChunkName = routeChunkModuleId ? getRouteChunkNameFromModuleId(routeChunkModuleId)?.replace(
                "unstable_",
                ""
              ) : null;
              let routeChunkSuffix = routeChunkName ? `-${(0, import_kebabCase.default)(routeChunkName)}` : "";
              return path7.posix.join(
                (ctx.reactRouterConfig.future.unstable_viteEnvironmentApi ? viteUserConfig?.environments?.client?.build?.assetsDir : viteUserConfig?.build?.assetsDir) ?? "assets",
                `[name]${routeChunkSuffix}-[hash].js`
              );
            }
          }
        },
        outDir: getClientBuildDirectory(ctx.reactRouterConfig)
      }
    })
  };
  let serverBundleIds = getServerBundleIds(ctx);
  if (serverBundleIds) {
    for (let serverBundleId of serverBundleIds) {
      const environmentName = `${SSR_BUNDLE_PREFIX}${serverBundleId}`;
      environmentOptionsResolvers[environmentName] = ({ viteUserConfig }) => mergeEnvironmentOptions(
        getBaseServerOptions({ viteUserConfig }),
        {
          build: {
            outDir: getServerBuildDirectory(ctx.reactRouterConfig, {
              serverBundleId
            })
          }
        },
        // Ensure server bundle environments extend the user's SSR
        // environment config if it exists
        viteUserConfig.environments?.ssr ?? {}
      );
    }
  } else {
    environmentOptionsResolvers.ssr = ({ viteUserConfig }) => mergeEnvironmentOptions(getBaseServerOptions({ viteUserConfig }), {
      build: {
        outDir: getServerBuildDirectory(ctx.reactRouterConfig)
      }
    });
  }
  if (ctx.reactRouterConfig.future.unstable_viteEnvironmentApi && viteCommand === "serve") {
    environmentOptionsResolvers[CSS_DEV_HELPER_ENVIRONMENT_NAME] = () => ({});
  }
  return environmentOptionsResolvers;
}
function resolveEnvironmentsOptions(environmentResolvers, resolverOptions) {
  let environmentOptions = {};
  for (let [environmentName, resolver] of Object.entries(
    environmentResolvers
  )) {
    environmentOptions[environmentName] = resolver(resolverOptions);
  }
  return environmentOptions;
}
function isNonNullable(x) {
  return x != null;
}
var import_node_crypto, fs4, path7, url, fse, babel2, import_react_router2, import_es_module_lexer, import_pick3, import_jsesc, import_picocolors4, import_kebabCase, CLIENT_NON_COMPONENT_EXPORTS, CLIENT_ROUTE_EXPORTS, BUILD_CLIENT_ROUTE_QUERY_STRING, SSR_BUNDLE_PREFIX, CSS_DEV_HELPER_ENVIRONMENT_NAME, virtualHmrRuntime, virtualInjectHmrRuntime, virtual2, getServerBuildDirectory, getClientBuildDirectory, defaultEntriesDir, defaultEntries, REACT_REFRESH_HEADER;
var init_plugin = __esm({
  "vite/plugin.ts"() {
    "use strict";
    import_node_crypto = require("crypto");
    fs4 = __toESM(require("fs"));
    path7 = __toESM(require("path"));
    url = __toESM(require("url"));
    fse = __toESM(require("fs-extra"));
    babel2 = __toESM(require("@babel/core"));
    import_react_router2 = require("react-router");
    import_es_module_lexer = require("es-module-lexer");
    import_pick3 = __toESM(require("lodash/pick"));
    import_jsesc = __toESM(require("jsesc"));
    import_picocolors4 = __toESM(require("picocolors"));
    import_kebabCase = __toESM(require("lodash/kebabCase"));
    init_typegen();
    init_invariant();
    init_babel();
    init_node_adapter();
    init_styles();
    init_virtual_module();
    init_resolve_file_url();
    init_combine_urls();
    init_remove_exports();
    init_ssr_externals();
    init_route_chunks();
    init_vite();
    init_config();
    init_with_props();
    CLIENT_NON_COMPONENT_EXPORTS = [
      "clientAction",
      "clientLoader",
      "unstable_clientMiddleware",
      "handle",
      "meta",
      "links",
      "shouldRevalidate"
    ];
    CLIENT_ROUTE_EXPORTS = [
      ...CLIENT_NON_COMPONENT_EXPORTS,
      "default",
      "ErrorBoundary",
      "HydrateFallback",
      "Layout"
    ];
    BUILD_CLIENT_ROUTE_QUERY_STRING = "?__react-router-build-client-route";
    SSR_BUNDLE_PREFIX = "ssrBundle_";
    CSS_DEV_HELPER_ENVIRONMENT_NAME = "__react_router_css_dev_helper__";
    virtualHmrRuntime = create("hmr-runtime");
    virtualInjectHmrRuntime = create("inject-hmr-runtime");
    virtual2 = {
      serverBuild: create("server-build"),
      serverManifest: create("server-manifest"),
      browserManifest: create("browser-manifest")
    };
    getServerBuildDirectory = (reactRouterConfig, { serverBundleId } = {}) => path7.join(
      reactRouterConfig.buildDirectory,
      "server",
      ...serverBundleId ? [serverBundleId] : []
    );
    getClientBuildDirectory = (reactRouterConfig) => path7.join(reactRouterConfig.buildDirectory, "client");
    defaultEntriesDir = path7.resolve(
      path7.dirname(require.resolve("@react-router/dev/package.json")),
      "dist",
      "config",
      "defaults"
    );
    defaultEntries = fse.readdirSync(defaultEntriesDir).map((filename3) => path7.join(defaultEntriesDir, filename3));
    invariant(defaultEntries.length > 0, "No default entries found");
    REACT_REFRESH_HEADER = `
import RefreshRuntime from "${virtualHmrRuntime.id}";

const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
let prevRefreshReg;
let prevRefreshSig;

if (import.meta.hot && !inWebWorker) {
  if (!window.__vite_plugin_react_preamble_installed__) {
    throw new Error(
      "React Router Vite plugin can't detect preamble. Something is wrong."
    );
  }

  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id) => {
    RefreshRuntime.register(type, __SOURCE__ + " " + id)
  };
  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
}`.replaceAll("\n", "");
  }
});

// vite/build.ts
var build_exports = {};
__export(build_exports, {
  build: () => build
});
async function build(root, viteBuildOptions) {
  await preloadVite();
  let vite2 = getVite();
  let configResult = await loadConfig({ rootDirectory: root });
  if (!configResult.ok) {
    throw new Error(configResult.error);
  }
  let config = configResult.value;
  let unstable_viteEnvironmentApi = config.future.unstable_viteEnvironmentApi;
  let viteMajor = parseInt(vite2.version.split(".")[0], 10);
  if (unstable_viteEnvironmentApi && viteMajor === 5) {
    throw new Error(
      "The future.unstable_viteEnvironmentApi option is not supported in Vite 5"
    );
  }
  return await (unstable_viteEnvironmentApi ? viteAppBuild(root, viteBuildOptions) : viteBuild(root, viteBuildOptions));
}
async function viteAppBuild(root, {
  assetsInlineLimit,
  clearScreen,
  config: configFile,
  emptyOutDir,
  force,
  logLevel,
  minify,
  mode,
  sourcemapClient,
  sourcemapServer
}) {
  let vite2 = getVite();
  let builder = await vite2.createBuilder({
    root,
    mode,
    configFile,
    build: {
      assetsInlineLimit,
      emptyOutDir,
      minify
    },
    optimizeDeps: { force },
    clearScreen,
    logLevel,
    plugins: [
      {
        name: "react-router:cli-config",
        configEnvironment(name) {
          if (sourcemapClient && name === "client") {
            return {
              build: {
                sourcemap: sourcemapClient
              }
            };
          }
          if (sourcemapServer && name !== "client") {
            return {
              build: {
                sourcemap: sourcemapServer
              }
            };
          }
        },
        configResolved(config) {
          let hasReactRouterPlugin = config.plugins.find(
            (plugin2) => plugin2.name === "react-router"
          );
          if (!hasReactRouterPlugin) {
            throw new Error(
              "React Router Vite plugin not found in Vite config"
            );
          }
        }
      }
    ]
  });
  await builder.buildApp();
}
async function viteBuild(root, {
  assetsInlineLimit,
  clearScreen,
  config: configFile,
  emptyOutDir,
  force,
  logLevel,
  minify,
  mode,
  sourcemapClient,
  sourcemapServer
}) {
  let viteUserConfig = {};
  let viteConfig = await resolveViteConfig({
    configFile,
    mode,
    root,
    plugins: [
      {
        name: "react-router:extract-vite-user-config",
        config(config) {
          viteUserConfig = config;
        }
      }
    ]
  });
  let ctx = extractPluginContext(viteConfig);
  if (!ctx) {
    console.error(
      import_picocolors5.default.red("React Router Vite plugin not found in Vite config")
    );
    process.exit(1);
  }
  async function buildEnvironment(environmentName) {
    let vite2 = getVite();
    let ssr = environmentName !== "client";
    let resolveOptions = environmentOptionsResolvers[environmentName];
    invariant(resolveOptions);
    let environmentBuildContext = {
      name: environmentName,
      resolveOptions
    };
    await vite2.build({
      root,
      mode,
      configFile,
      build: {
        assetsInlineLimit,
        emptyOutDir,
        minify,
        ssr,
        sourcemap: ssr ? sourcemapServer : sourcemapClient
      },
      optimizeDeps: { force },
      clearScreen,
      logLevel,
      ...{
        __reactRouterPluginContext: ctx,
        __reactRouterEnvironmentBuildContext: environmentBuildContext
      }
    });
  }
  let { reactRouterConfig, buildManifest } = ctx;
  invariant(buildManifest, "Expected build manifest to be present");
  let environmentOptionsResolvers = await getEnvironmentOptionsResolvers(
    ctx,
    "build"
  );
  let environmentsOptions = resolveEnvironmentsOptions(
    environmentOptionsResolvers,
    { viteUserConfig }
  );
  await cleanBuildDirectory(viteConfig, ctx);
  await buildEnvironment("client");
  let serverEnvironmentNames = getServerEnvironmentKeys(
    ctx,
    environmentOptionsResolvers
  );
  await Promise.all(serverEnvironmentNames.map(buildEnvironment));
  await cleanViteManifests(environmentsOptions, ctx);
  await reactRouterConfig.buildEnd?.({
    buildManifest,
    reactRouterConfig,
    viteConfig
  });
}
var import_picocolors5;
var init_build = __esm({
  "vite/build.ts"() {
    "use strict";
    import_picocolors5 = __toESM(require("picocolors"));
    init_config();
    init_plugin();
    init_invariant();
    init_vite();
  }
});

// vite/dev.ts
var dev_exports = {};
__export(dev_exports, {
  dev: () => dev
});
async function dev(root, {
  clearScreen,
  config: configFile,
  cors,
  force,
  host,
  logLevel,
  mode,
  open,
  port,
  strictPort
}) {
  await preloadVite();
  let vite2 = getVite();
  let server = await vite2.createServer({
    root,
    mode,
    configFile,
    server: { open, cors, host, port, strictPort },
    optimizeDeps: { force },
    clearScreen,
    logLevel
  });
  if (!server.config.plugins.find((plugin2) => plugin2.name === "react-router")) {
    console.error(
      import_picocolors6.default.red("React Router Vite plugin not found in Vite config")
    );
    process.exit(1);
  }
  await server.listen();
  server.printUrls();
  let customShortcuts = [
    {
      key: "p",
      description: "start/stop the profiler",
      async action(server2) {
        if (getSession()) {
          await stop(server2.config.logger.info);
        } else {
          await start(() => {
            server2.config.logger.info("Profiler started");
          });
        }
      }
    }
  ];
  server.bindCLIShortcuts({ print: true, customShortcuts });
}
var import_picocolors6;
var init_dev = __esm({
  "vite/dev.ts"() {
    "use strict";
    import_picocolors6 = __toESM(require("picocolors"));
    init_vite();
    init_profiler();
  }
});

// cli/run.ts
var import_arg = __toESM(require("arg"));
var import_semver = __toESM(require("semver"));
var import_picocolors8 = __toESM(require("picocolors"));

// cli/commands.ts
var path8 = __toESM(require("path"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_package_json2 = __toESM(require("@npmcli/package-json"));
var import_exit_hook = __toESM(require("exit-hook"));
var import_picocolors7 = __toESM(require("picocolors"));
var import_react_router3 = require("react-router");
init_config();

// config/format.ts
function formatRoutes(routeManifest, format) {
  switch (format) {
    case "json":
      return formatRoutesAsJson(routeManifest);
    case "jsx":
      return formatRoutesAsJsx(routeManifest);
  }
}
function formatRoutesAsJson(routeManifest) {
  function handleRoutesRecursive(parentId) {
    let routes2 = Object.values(routeManifest).filter(
      (route) => route.parentId === parentId
    );
    let children = [];
    for (let route of routes2) {
      children.push({
        id: route.id,
        index: route.index,
        path: route.path,
        caseSensitive: route.caseSensitive,
        file: route.file,
        children: handleRoutesRecursive(route.id)
      });
    }
    if (children.length > 0) {
      return children;
    }
    return void 0;
  }
  return JSON.stringify(handleRoutesRecursive() || null, null, 2);
}
function formatRoutesAsJsx(routeManifest) {
  let output = "<Routes>";
  function handleRoutesRecursive(parentId, level = 1) {
    let routes2 = Object.values(routeManifest).filter(
      (route) => route.parentId === parentId
    );
    let indent = Array(level * 2).fill(" ").join("");
    for (let route of routes2) {
      output += "\n" + indent;
      output += `<Route${route.path ? ` path=${JSON.stringify(route.path)}` : ""}${route.index ? " index" : ""}${route.file ? ` file=${JSON.stringify(route.file)}` : ""}>`;
      if (handleRoutesRecursive(route.id, level + 1)) {
        output += "\n" + indent;
        output += "</Route>";
      } else {
        output = output.slice(0, -1) + " />";
      }
    }
    return routes2.length > 0;
  }
  handleRoutesRecursive();
  output += "\n</Routes>";
  return output;
}

// cli/useJavascript.ts
var babel = __toESM(require("@babel/core"));
var import_plugin_syntax_jsx = __toESM(require("@babel/plugin-syntax-jsx"));
var import_preset_typescript = __toESM(require("@babel/preset-typescript"));
var import_prettier = __toESM(require("prettier"));
function transpile(tsx, options = {}) {
  let mjs = babel.transformSync(tsx, {
    compact: false,
    cwd: options.cwd,
    filename: options.filename,
    plugins: [import_plugin_syntax_jsx.default],
    presets: [[import_preset_typescript.default, { jsx: "preserve" }]],
    retainLines: true
  });
  if (!mjs || !mjs.code) throw new Error("Could not parse TypeScript");
  return import_prettier.default.format(mjs.code, { parser: "babel" });
}

// cli/commands.ts
init_profiler();
init_typegen();
init_vite();
async function routes(reactRouterRoot, flags = {}) {
  let rootDirectory = reactRouterRoot ?? process.cwd();
  let configResult = await loadConfig({ rootDirectory });
  if (!configResult.ok) {
    console.error(import_picocolors7.default.red(configResult.error));
    process.exit(1);
  }
  let format = flags.json ? "json" : "jsx";
  console.log(formatRoutes(configResult.value.routes, format));
}
async function build2(root, options = {}) {
  if (!root) {
    root = process.env.REACT_ROUTER_ROOT || process.cwd();
  }
  let { build: build3 } = await Promise.resolve().then(() => (init_build(), build_exports));
  if (options.profile) {
    await start();
  }
  try {
    await build3(root, options);
  } finally {
    await stop(console.info);
  }
}
async function dev2(root, options = {}) {
  let { dev: dev3 } = await Promise.resolve().then(() => (init_dev(), dev_exports));
  if (options.profile) {
    await start();
  }
  (0, import_exit_hook.default)(() => stop(console.info));
  await dev3(root, options);
  await new Promise(() => {
  });
}
var clientEntries = ["entry.client.tsx", "entry.client.js", "entry.client.jsx"];
var serverEntries = ["entry.server.tsx", "entry.server.js", "entry.server.jsx"];
var entries = ["entry.client", "entry.server"];
var conjunctionListFormat = new Intl.ListFormat("en", {
  style: "long",
  type: "conjunction"
});
async function generateEntry(entry, reactRouterRoot, flags = {}) {
  if (!entry) {
    await generateEntry("entry.client", reactRouterRoot, flags);
    await generateEntry("entry.server", reactRouterRoot, flags);
    return;
  }
  let rootDirectory = reactRouterRoot ?? process.cwd();
  let configResult = await loadConfig({ rootDirectory });
  if (!configResult.ok) {
    console.error(import_picocolors7.default.red(configResult.error));
    return;
  }
  let appDirectory = configResult.value.appDirectory;
  if (!entries.includes(entry)) {
    let entriesArray = Array.from(entries);
    let list = conjunctionListFormat.format(entriesArray);
    console.error(
      import_picocolors7.default.red(`Invalid entry file. Valid entry files are ${list}`)
    );
    return;
  }
  let pkgJson = await import_package_json2.default.load(rootDirectory);
  let deps = pkgJson.content.dependencies ?? {};
  if (!deps["@react-router/node"]) {
    console.error(import_picocolors7.default.red(`No default server entry detected.`));
    return;
  }
  let defaultsDirectory = path8.resolve(
    path8.dirname(require.resolve("@react-router/dev/package.json")),
    "dist",
    "config",
    "defaults"
  );
  let defaultEntryClient = path8.resolve(defaultsDirectory, "entry.client.tsx");
  let defaultEntryServer = path8.resolve(
    defaultsDirectory,
    `entry.server.node.tsx`
  );
  let isServerEntry = entry === "entry.server";
  let contents = isServerEntry ? await createServerEntry(rootDirectory, appDirectory, defaultEntryServer) : await createClientEntry(rootDirectory, appDirectory, defaultEntryClient);
  let useTypeScript = flags.typescript ?? true;
  let outputExtension = useTypeScript ? "tsx" : "jsx";
  let outputEntry = `${entry}.${outputExtension}`;
  let outputFile2 = path8.resolve(appDirectory, outputEntry);
  if (!useTypeScript) {
    let javascript = transpile(contents, {
      cwd: rootDirectory,
      filename: isServerEntry ? defaultEntryServer : defaultEntryClient
    });
    await import_fs_extra.default.writeFile(outputFile2, javascript, "utf-8");
  } else {
    await import_fs_extra.default.writeFile(outputFile2, contents, "utf-8");
  }
  console.log(
    import_picocolors7.default.blue(
      `Entry file ${entry} created at ${path8.relative(
        rootDirectory,
        outputFile2
      )}.`
    )
  );
}
async function checkForEntry(rootDirectory, appDirectory, entries2) {
  for (let entry of entries2) {
    let entryPath = path8.resolve(appDirectory, entry);
    let exists = await import_fs_extra.default.pathExists(entryPath);
    if (exists) {
      let relative8 = path8.relative(rootDirectory, entryPath);
      console.error(import_picocolors7.default.red(`Entry file ${relative8} already exists.`));
      return process.exit(1);
    }
  }
}
async function createServerEntry(rootDirectory, appDirectory, inputFile) {
  await checkForEntry(rootDirectory, appDirectory, serverEntries);
  let contents = await import_fs_extra.default.readFile(inputFile, "utf-8");
  return contents;
}
async function createClientEntry(rootDirectory, appDirectory, inputFile) {
  await checkForEntry(rootDirectory, appDirectory, clientEntries);
  let contents = await import_fs_extra.default.readFile(inputFile, "utf-8");
  return contents;
}
async function typegen(root, flags) {
  root ??= process.cwd();
  if (flags.watch) {
    await preloadVite();
    const vite2 = getVite();
    const logger = vite2.createLogger("info", { prefix: "[react-router]" });
    await watch(root, { logger });
    await new Promise(() => {
    });
    return;
  }
  await run(root);
}

// cli/run.ts
var helpText = `
${import_picocolors8.default.blueBright("react-router")}

  ${import_picocolors8.default.underline("Usage")}:
    $ react-router build [${import_picocolors8.default.yellowBright("projectDir")}]
    $ react-router dev [${import_picocolors8.default.yellowBright("projectDir")}]
    $ react-router routes [${import_picocolors8.default.yellowBright("projectDir")}]

  ${import_picocolors8.default.underline("Options")}:
    --help, -h          Print this help message and exit
    --version, -v       Print the CLI version and exit
    --no-color          Disable ANSI colors in console output
  \`build\` Options:
    --assetsInlineLimit Static asset base64 inline threshold in bytes (default: 4096) (number)
    --clearScreen       Allow/disable clear screen when logging (boolean)
    --config, -c        Use specified config file (string)
    --emptyOutDir       Force empty outDir when it's outside of root (boolean)
    --logLevel, -l      Info | warn | error | silent (string)
    --minify            Enable/disable minification, or specify minifier to use (default: "esbuild") (boolean | "terser" | "esbuild")
    --mode, -m          Set env mode (string)
    --profile           Start built-in Node.js inspector
    --sourcemapClient   Output source maps for client build (default: false) (boolean | "inline" | "hidden")
    --sourcemapServer   Output source maps for server build (default: false) (boolean | "inline" | "hidden")
  \`dev\` Options:
    --clearScreen       Allow/disable clear screen when logging (boolean)
    --config, -c        Use specified config file (string)
    --cors              Enable CORS (boolean)
    --force             Force the optimizer to ignore the cache and re-bundle (boolean)
    --host              Specify hostname (string)
    --logLevel, -l      Info | warn | error | silent (string)
    --mode, -m          Set env mode (string)
    --open              Open browser on startup (boolean | string)
    --port              Specify port (number)
    --profile           Start built-in Node.js inspector
    --strictPort        Exit if specified port is already in use (boolean)
  \`routes\` Options:
    --config, -c        Use specified Vite config file (string)
    --json              Print the routes as JSON
  \`reveal\` Options:
    --config, -c        Use specified Vite config file (string)
    --no-typescript     Generate plain JavaScript files
  \`typegen\` Options:
    --watch             Automatically regenerate types whenever route config (\`routes.ts\`) or route modules change

  ${import_picocolors8.default.underline("Build your project")}:

    $ react-router build

  ${import_picocolors8.default.underline("Run your project locally in development")}:

    $ react-router dev

  ${import_picocolors8.default.underline("Show all routes in your app")}:

    $ react-router routes
    $ react-router routes my-app
    $ react-router routes --json
    $ react-router routes --config vite.react-router.config.ts

  ${import_picocolors8.default.underline("Reveal the used entry point")}:

    $ react-router reveal entry.client
    $ react-router reveal entry.server
    $ react-router reveal entry.client --no-typescript
    $ react-router reveal entry.server --no-typescript
    $ react-router reveal entry.server --config vite.react-router.config.ts

  ${import_picocolors8.default.underline("Generate types for route modules")}:

   $ react-router typegen
   $ react-router typegen --watch
`;
async function run2(argv = process.argv.slice(2)) {
  let versions = process.versions;
  let MINIMUM_NODE_VERSION = 20;
  if (versions && versions.node && import_semver.default.major(versions.node) < MINIMUM_NODE_VERSION) {
    console.warn(
      `\uFE0F\u26A0\uFE0F Oops, Node v${versions.node} detected. react-router requires a Node version greater than ${MINIMUM_NODE_VERSION}.`
    );
  }
  let isBooleanFlag = (arg2) => {
    let index = argv.indexOf(arg2);
    let nextArg = argv[index + 1];
    return !nextArg || nextArg.startsWith("-");
  };
  let args = (0, import_arg.default)(
    {
      "--force": Boolean,
      "--help": Boolean,
      "-h": "--help",
      "--json": Boolean,
      "--token": String,
      "--typescript": Boolean,
      "--no-typescript": Boolean,
      "--version": Boolean,
      "-v": "--version",
      "--port": Number,
      "-p": "--port",
      "--config": String,
      "-c": "--config",
      "--assetsInlineLimit": Number,
      "--clearScreen": Boolean,
      "--cors": Boolean,
      "--emptyOutDir": Boolean,
      "--host": isBooleanFlag("--host") ? Boolean : String,
      "--logLevel": String,
      "-l": "--logLevel",
      "--minify": String,
      "--mode": String,
      "-m": "--mode",
      "--open": isBooleanFlag("--open") ? Boolean : String,
      "--strictPort": Boolean,
      "--profile": Boolean,
      "--sourcemapClient": isBooleanFlag("--sourcemapClient") ? Boolean : String,
      "--sourcemapServer": isBooleanFlag("--sourcemapServer") ? Boolean : String,
      "--watch": Boolean
    },
    {
      argv
    }
  );
  let input = args._;
  let flags = Object.entries(args).reduce((acc, [key, value]) => {
    key = key.replace(/^--/, "");
    acc[key] = value;
    return acc;
  }, {});
  if (flags.help) {
    console.log(helpText);
    return;
  }
  if (flags.version) {
    let version = require("../../package.json").version;
    console.log(version);
    return;
  }
  flags.interactive = flags.interactive ?? require.main === module;
  if (args["--no-typescript"]) {
    flags.typescript = false;
  }
  let command = input[0];
  switch (command) {
    case "routes":
      await routes(input[1], flags);
      break;
    case "build":
      await build2(input[1], flags);
      break;
    case "reveal": {
      await generateEntry(input[1], input[2], flags);
      break;
    }
    case "dev":
      await dev2(input[1], flags);
      break;
    case "typegen":
      await typegen(input[1], flags);
      break;
    default:
      await dev2(input[0], flags);
  }
}

// cli/index.ts
run2().then(
  () => {
    process.exit(0);
  },
  (error) => {
    if (error) console.error(error);
    process.exit(1);
  }
);
