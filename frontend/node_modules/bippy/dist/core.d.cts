import * as React from 'react';
import { R as ReactDevToolsGlobalHook, F as Fiber, C as ContextDependency, M as MemoizedState, a as ReactRenderer } from './jsx-runtime-LhDmw-G0.cjs';
export { D as Dependencies, E as Effect, P as Props } from './jsx-runtime-LhDmw-G0.cjs';
import { FiberRoot } from 'react-reconciler';
export { BundleType, ComponentSelector, DevToolsConfig, FiberRoot, Flags, HasPseudoClassSelector, HookType, HostConfig, LanePriority, Lanes, MutableSource, OpaqueHandle, OpaqueRoot, React$AbstractComponent, ReactConsumer, ReactContext, ReactPortal, ReactProvider, ReactProviderType, RefObject, RoleSelector, RootTag, Selector, Source, SuspenseHydrationCallbacks, TestNameSelector, TextSelector, Thenable, TransitionTracingCallbacks, TypeOfMode, WorkTag } from 'react-reconciler';
import 'react/jsx-runtime';

declare const INSTALL_HOOK_SCRIPT_STRING = "(()=>{try{var t=()=>{};const n=new Map;let o=0;globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__={checkDCE:t,supportsFiber:!0,supportsFlight:!0,hasUnsupportedRendererAttached:!1,renderers:n,onCommitFiberRoot:t,onCommitFiberUnmount:t,onPostCommitFiberRoot:t,inject(t){var e=++o;return n.set(e,t),globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__._instrumentationIsActive=!0,e},_instrumentationIsActive:!1,_script:!0}}catch{}})()";

declare const version: string | undefined;
declare const BIPPY_INSTRUMENTATION_STRING: string;
declare const isRealReactDevtools: (rdtHook?: ReactDevToolsGlobalHook) => boolean;
declare const isReactRefresh: (rdtHook?: ReactDevToolsGlobalHook) => boolean;
declare const installRDTHook: (onActive?: () => unknown) => ReactDevToolsGlobalHook;
declare const patchRDTHook: (onActive?: () => unknown) => void;
declare const hasRDTHook: () => boolean;
/**
 * Returns the current React DevTools global hook.
 */
declare const getRDTHook: (onActive?: () => unknown) => ReactDevToolsGlobalHook;
declare const isClientEnvironment: () => boolean;
/**
 * Usually used purely for side effect
 */
declare const safelyInstallRDTHook: () => void;

declare const FunctionComponentTag = 0;
declare const ClassComponentTag = 1;
declare const HostRootTag = 3;
declare const HostComponentTag = 5;
declare const HostTextTag = 6;
declare const FragmentTag = 7;
declare const ContextConsumerTag = 9;
declare const ForwardRefTag = 11;
declare const SuspenseComponentTag = 13;
declare const MemoComponentTag = 14;
declare const SimpleMemoComponentTag = 15;
declare const DehydratedSuspenseComponentTag = 18;
declare const OffscreenComponentTag = 22;
declare const LegacyHiddenComponentTag = 23;
declare const HostHoistableTag = 26;
declare const HostSingletonTag = 27;
declare const CONCURRENT_MODE_NUMBER = 60111;
declare const ELEMENT_TYPE_SYMBOL_STRING = "Symbol(react.element)";
declare const TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING = "Symbol(react.transitional.element)";
declare const CONCURRENT_MODE_SYMBOL_STRING = "Symbol(react.concurrent_mode)";
declare const DEPRECATED_ASYNC_MODE_SYMBOL_STRING = "Symbol(react.async_mode)";
/**
 * Returns `true` if object is a React Element.
 *
 * @see https://react.dev/reference/react/isValidElement
 */
declare const isValidElement: (element: unknown) => element is React.ReactElement;
/**
 * Returns `true` if object is a React Fiber.
 */
declare const isValidFiber: (fiber: unknown) => fiber is Fiber;
/**
 * Returns `true` if fiber is a host fiber. Host fibers are DOM nodes in react-dom, `View` in react-native, etc.
 *
 * @see https://reactnative.dev/architecture/glossary#host-view-tree-and-host-view
 */
declare const isHostFiber: (fiber: Fiber) => boolean;
/**
 * Returns `true` if fiber is a composite fiber. Composite fibers are fibers that can render (like functional components, class components, etc.)
 *
 * @see https://reactnative.dev/architecture/glossary#react-composite-components
 */
declare const isCompositeFiber: (fiber: Fiber) => boolean;
/**
 * Traverses up or down a {@link Fiber}'s contexts, return `true` to stop and select the current and previous context value.
 */
declare const traverseContexts: (fiber: Fiber, selector: (nextValue: ContextDependency<unknown> | null | undefined, prevValue: ContextDependency<unknown> | null | undefined) => boolean | void) => boolean;
/**
 * Traverses up or down a {@link Fiber}'s states, return `true` to stop and select the current and previous state value. This stores both state values and effects.
 */
declare const traverseState: (fiber: Fiber, selector: (nextValue: MemoizedState | null | undefined, prevValue: MemoizedState | null | undefined) => boolean | void) => boolean;
/**
 * Traverses up or down a {@link Fiber}'s props, return `true` to stop and select the current and previous props value.
 */
declare const traverseProps: (fiber: Fiber, selector: (propName: string, nextValue: unknown, prevValue: unknown) => boolean | void) => boolean;
/**
 * Returns `true` if the {@link Fiber} has rendered. Note that this does not mean the fiber has rendered in the current commit, just that it has rendered in the past.
 */
declare const didFiberRender: (fiber: Fiber) => boolean;
/**
 * Returns `true` if the {@link Fiber} has committed. Note that this does not mean the fiber has committed in the current commit, just that it has committed in the past.
 */
declare const didFiberCommit: (fiber: Fiber) => boolean;
/**
 * Returns all host {@link Fiber}s that have committed and rendered.
 */
declare const getMutatedHostFibers: (fiber: Fiber) => Fiber[];
/**
 * Returns the stack of {@link Fiber}s from the current fiber to the root fiber.
 *
 * @example
 * ```ts
 * [fiber, fiber.return, fiber.return.return, ...]
 * ```
 */
declare const getFiberStack: (fiber: Fiber) => Fiber[];
/**
 * Returns `true` if the {@link Fiber} should be filtered out during reconciliation.
 */
declare const shouldFilterFiber: (fiber: Fiber) => boolean;
/**
 * Returns the nearest host {@link Fiber} to the current {@link Fiber}.
 */
declare const getNearestHostFiber: (fiber: Fiber, ascending?: boolean) => Fiber | null;
/**
 * Returns all host {@link Fiber}s in the tree that are associated with the current {@link Fiber}.
 */
declare const getNearestHostFibers: (fiber: Fiber) => Fiber[];
/**
 * Traverses up or down a {@link Fiber}, return `true` to stop and select a node.
 */
declare const traverseFiber: (fiber: Fiber | null, selector: (node: Fiber) => boolean | void, ascending?: boolean) => Fiber | null;
/**
 * Returns the timings of the {@link Fiber}.
 *
 * @example
 * ```ts
 * const { selfTime, totalTime } = getTimings(fiber);
 * console.log(selfTime, totalTime);
 * ```
 */
declare const getTimings: (fiber?: Fiber | null | undefined) => {
    selfTime: number;
    totalTime: number;
};
/**
 * Returns `true` if the {@link Fiber} uses React Compiler's memo cache.
 */
declare const hasMemoCache: (fiber: Fiber) => boolean;
/**
 * Returns the type (e.g. component definition) of the {@link Fiber}
 */
declare const getType: (type: unknown) => React.ComponentType<unknown> | null;
/**
 * Returns the display name of the {@link Fiber} type.
 */
declare const getDisplayName: (type: unknown) => string | null;
/**
 * Returns the build type of the React renderer.
 */
declare const detectReactBuildType: (renderer: ReactRenderer) => "development" | "production";
/**
 * Returns `true` if bippy's instrumentation is active.
 */
declare const isInstrumentationActive: () => boolean;
/**
 * Returns the latest fiber (since it may be double-buffered).
 */
declare const getLatestFiber: (fiber: Fiber) => Fiber;
type RenderPhase = 'mount' | 'update' | 'unmount';
type RenderHandler = <S>(fiber: Fiber, phase: RenderPhase, state?: S) => unknown;
declare const fiberIdMap: WeakMap<Fiber, number>;
declare const setFiberId: (fiber: Fiber, id?: number) => void;
declare const getFiberId: (fiber: Fiber) => number;
declare const mountFiberRecursively: (onRender: RenderHandler, firstChild: Fiber, traverseSiblings: boolean) => void;
declare const updateFiberRecursively: (onRender: RenderHandler, nextFiber: Fiber, prevFiber: Fiber, parentFiber: Fiber | null) => void;
declare const unmountFiber: (onRender: RenderHandler, fiber: Fiber) => void;
declare const unmountFiberChildrenRecursively: (onRender: RenderHandler, fiber: Fiber) => void;
/**
 * Creates a fiber visitor function. Must pass a fiber root and a render handler.
 * @example
 * traverseRenderedFibers(root, (fiber, phase) => {
 *   console.log(phase)
 * })
 */
declare const traverseRenderedFibers: (root: FiberRoot, onRender: RenderHandler) => void;
/**
 * @deprecated use `traverseRenderedFibers` instead
 */
declare const createFiberVisitor: ({ onRender, }: {
    onRender: RenderHandler;
    onError: (error: unknown) => unknown;
}) => (<S>(_rendererID: number, root: FiberRoot | Fiber, _state?: S) => void);
interface InstrumentationOptions {
    onCommitFiberRoot?: (rendererID: number, root: FiberRoot, priority: void | number) => unknown;
    onCommitFiberUnmount?: (rendererID: number, fiber: Fiber) => unknown;
    onPostCommitFiberRoot?: (rendererID: number, root: FiberRoot) => unknown;
    onActive?: () => unknown;
    name?: string;
}
/**
 * Instruments the DevTools hook.
 * @example
 * const hook = instrument({
 *   onActive() {
 *     console.log('initialized');
 *   },
 *   onCommitFiberRoot(rendererID, root) {
 *     console.log('fiberRoot', root.current)
 *   },
 * });
 */
declare const instrument: (options: InstrumentationOptions) => ReactDevToolsGlobalHook;
declare const getFiberFromHostInstance: <T>(hostInstance: T) => Fiber | null;
declare const INSTALL_ERROR: Error;
declare const _fiberRoots: Set<any>;
declare const secure: (options: InstrumentationOptions, secureOptions?: {
    minReactMajorVersion?: number;
    dangerouslyRunInProduction?: boolean;
    onError?: (error?: unknown) => unknown;
    installCheckTimeout?: number;
    isProduction?: boolean;
}) => InstrumentationOptions;
/**
 * a wrapper around the {@link instrument} function that sets the `onCommitFiberRoot` hook.
 *
 * @example
 * onCommitFiberRoot((root) => {
 *   console.log(root.current);
 * });
 */
declare const onCommitFiberRoot: (handler: (root: FiberRoot) => void) => ReactDevToolsGlobalHook;

export { BIPPY_INSTRUMENTATION_STRING, CONCURRENT_MODE_NUMBER, CONCURRENT_MODE_SYMBOL_STRING, ClassComponentTag, ContextConsumerTag, ContextDependency, DEPRECATED_ASYNC_MODE_SYMBOL_STRING, DehydratedSuspenseComponentTag, ELEMENT_TYPE_SYMBOL_STRING, Fiber, ForwardRefTag, FragmentTag, FunctionComponentTag, HostComponentTag, HostHoistableTag, HostRootTag, HostSingletonTag, HostTextTag, INSTALL_ERROR, INSTALL_HOOK_SCRIPT_STRING, type InstrumentationOptions, LegacyHiddenComponentTag, MemoComponentTag, MemoizedState, OffscreenComponentTag, ReactDevToolsGlobalHook, ReactRenderer, type RenderHandler, type RenderPhase, SimpleMemoComponentTag, SuspenseComponentTag, TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING, _fiberRoots, createFiberVisitor, detectReactBuildType, didFiberCommit, didFiberRender, fiberIdMap, getDisplayName, getFiberFromHostInstance, getFiberId, getFiberStack, getLatestFiber, getMutatedHostFibers, getNearestHostFiber, getNearestHostFibers, getRDTHook, getTimings, getType, hasMemoCache, hasRDTHook, installRDTHook, instrument, isClientEnvironment, isCompositeFiber, isHostFiber, isInstrumentationActive, isReactRefresh, isRealReactDevtools, isValidElement, isValidFiber, mountFiberRecursively, onCommitFiberRoot, patchRDTHook, safelyInstallRDTHook, secure, setFiberId, shouldFilterFiber, traverseContexts, traverseFiber, traverseProps, traverseRenderedFibers, traverseState, unmountFiber, unmountFiberChildrenRecursively, updateFiberRecursively, version };
